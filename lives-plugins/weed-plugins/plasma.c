/////////////////////////////////////////////////////////////////////////////
// Weed plasma plugin, version 1
// Compiled with Builder version 4.0,0-pre
// autogenerated from script plasma.script

// released under the GNU GPL version 3 or higher
// see file COPYING or www.gnu.org for details

// (c) w.p van paasen and salsaman 2023
/////////////////////////////////////////////////////////////////////////////

static int package_version = 1; // version of this package

/////////////////////////////////////////////////////////////////////////////

#define _UNIQUE_ID_ "0XA5478ADFCD0B956"

#define NEED_PALETTE_UTILS
#include <weed/weed-plugin-utils.h>
//////////////////////////////////////////////////////////////////

#include <math.h>

static int verbosity = WEED_VERBOSITY_ERROR;

typedef struct {
  uint16_t pos1, pos2, pos3, pos4, tpos1, tpos2, tpos3, tpos4;
} sdata_t;



typedef struct {
  short r;
  short g;
  short b;
} color_t;

static int aSin[512];
static color_t colors[256];

static void plasma_prep(void) {
  int i;
  float rad;

  for (i = 0; i < 512; i++) {
    rad = ((float)i * 0.703125) * 0.0174532;
    aSin[i] = sin(rad) * 1024;
  }

  for (i = 0; i < 64; ++i) {
    colors[i].r = i << 2;
    colors[i].g = 255 - ((i << 2) + 1);
    colors[i + 64].r = 255;
    colors[i + 64].g = (i << 2) + 1;
    colors[i + 128].r = 255 - ((i << 2) + 1);
    colors[i + 128].g = 255 - ((i << 2) + 1);
    colors[i + 192].g = (i << 2) + 1;
  }
}

/////////////////////////////////////////////////////////////////////////////

static weed_error_t plasma_init(weed_plant_t *inst) {
  weed_plant_t *out_chan = weed_get_out_channel(inst, 0);
  int width = weed_channel_get_width(out_chan);
  int height = weed_channel_get_height(out_chan);
  int orow = weed_channel_get_stride(out_chan);
  const int pal = (const int)weed_channel_get_palette(out_chan);
  const int psize = (const int)pixel_size((int)pal);
  sdata_t *sdata;
  if (!(weed_instance_get_flags(inst) & WEED_INSTANCE_UPDATE_GUI_ONLY)) {
    sdata = (sdata_t *)weed_calloc(1, sizeof(sdata_t));
    if (!sdata) return WEED_ERROR_MEMORY_ALLOCATION;
    weed_set_instance_data(inst, sdata);
  }
  else sdata = weed_get_instance_data(inst, sdata);

  return WEED_SUCCESS;
}


static weed_error_t plasma_deinit(weed_plant_t *inst) {
  sdata_t *sdata = weed_get_instance_data(inst, sdata);

  if (sdata) weed_free(sdata);
  weed_set_instance_data(inst, NULL);

  return WEED_SUCCESS;
}


static weed_error_t plasma_process(weed_plant_t *inst, weed_timecode_t tc) {
  weed_plant_t *out_chan = weed_get_out_channel(inst, 0);
  unsigned char *dst = weed_channel_get_pixel_data(out_chan);
  int width = weed_channel_get_width(out_chan);
  int height = weed_channel_get_height(out_chan);
  int orow = weed_channel_get_stride(out_chan);
  const int pal = (const int)weed_channel_get_palette(out_chan);
  const int psize = (const int)pixel_size((int)pal);
  sdata_t *sdata = weed_get_instance_data(inst, sdata);
  if (!sdata) return WEED_ERROR_REINIT_NEEDED;
  else {

    do {
        unsigned char *end;
        uint8_t index;
        int x, widthx = width * psize;
        int offs = orow - widthx;

        sdata->tpos4 = sdata->pos4;
        sdata->tpos3 = sdata->pos3;

        end = dst + height * widthx;

        while (dst < end) {
          sdata->tpos1 = sdata->pos1 + 5;
          sdata->tpos2 = sdata->pos2 + 3;
          sdata->tpos3 &= 511;
          sdata->tpos4 &= 511;

          for (int j = 0; j < width; ++j) {
            sdata->tpos1 &= 511;
            sdata->tpos2 &= 511;
            x = aSin[sdata->tpos1] + aSin[sdata->tpos2] + aSin[sdata->tpos3] + aSin[sdata->tpos4];
            index = 128 + (x >> 4);
            *dst++ = colors[index].r;
            *dst++ = colors[index].g;
            *dst++ = 0;
            if (pal == WEED_PALETTE_RGBA32) *dst++ = 255;
            sdata->tpos1 += 5;
            sdata->tpos2 += 3;
          }
          dst += offs;
          sdata->tpos4 += 3;
          sdata->tpos3 += 1;
        }

        sdata->pos1 += 9;
        sdata->pos3 += 8;
    } while (0);
  }

  return WEED_SUCCESS;
}


WEED_SETUP_START(203, 202) {
  weed_plant_t *host_info = weed_get_host_info(plugin_info);
  weed_plant_t *filter_class;
  uint64_t unique_id;
  int palette_list[] = {WEED_PALETTE_RGB24, WEED_PALETTE_RGBA32, WEED_PALETTE_END};
  weed_plant_t *out_chantmpls[] = {
      weed_channel_template_init("out_channel0", 0),
      NULL};
  int filter_flags = 0;

  verbosity = weed_get_host_verbosity(host_info);

  filter_class = weed_filter_class_init("plasma", "salsaman", 1, filter_flags, palette_list,
    plasma_init, plasma_process, plasma_deinit, NULL, out_chantmpls, NULL, NULL);

  weed_set_string_value(filter_class, WEED_LEAF_EXTRA_AUTHORS, "w.p van paasen");
  weed_filter_set_description(filter_class, "Generates plasma pattern");

  weed_plugin_info_add_filter_class(plugin_info, filter_class);

  if (!sscanf(_UNIQUE_ID_, "0X%lX", &unique_id) || !sscanf(_UNIQUE_ID_, "0x%lx", &unique_id)) {
    weed_set_int64_value(plugin_info, WEED_LEAF_UNIQUE_ID, unique_id);
  }

  do {
    plasma_prep();
  } while (0);

  weed_plugin_set_package_version(plugin_info, package_version);
}
WEED_SETUP_END;

