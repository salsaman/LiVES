/////////////////////////////////////////////////////////////////////////////
// Weed rotozoom plugin, version 1
// Compiled with Builder version 3.2.1-pre
// autogenerated from script by effecTV
/////////////////////////////////////////////////////////////////////////////

static int package_version = 1; // version of this package

/////////////////////////////////////////////////////////////////////////////

#define _UNIQUE_ID_ "0XB54A97FB2F71A6C8"

#define NEED_PALETTE_UTILS

#ifndef NEED_LOCAL_WEED_PLUGIN
#include <weed/weed-plugin.h>
#include <weed/weed-utils.h> // optional
#include <weed/weed-plugin-utils.h> // optional
#else
#include "../../libweed/weed-plugin.h"
#include "../../libweed/weed-utils.h" // optional
#include "../../libweed/weed-plugin-utils.h" // optional
#endif

#include "weed-plugin-utils.c"

//////////////////////////////////////////////////////////////////

#include <math.h>
#include <stdio.h>

static int verbosity = WEED_VERBOSITY_ERROR;

typedef struct {
  int path, zpath ;
} sdata_t;

enum {
  P_zoom,
  P_autozoom,
};

static int roto[256];
static int roto2[256];

/////////////////////////////////////////////////////////////

static void draw_tile(int stepx, int stepy, int zoom, unsigned char *src, unsigned char *dst,
                      int video_width, int irowstride, int orowstride, int video_height,
                      int dheight, int offset, int psize) {
  int x, y, xd, yd, a, b, sx = 0, sy = 0;
  int origin, i, j;

  xd = (stepx * zoom) >> 12;
  yd = (stepy * zoom) >> 12;

  sx = -yd * offset;
  sy = xd * offset;

  /* Stepping across and down the screen, each screen row has a
     starting coordinate in the texture: (sx, sy).  As each screen
     row is traversed, the current texture coordinate (x, y) is
     modified by (xd, yd), which are (sin(rot), cos(rot)) multiplied
     by the current zoom factor.  For each vertical step, (xd, yd)
     is rotated 90 degrees, to become (-yd, xd).

     More fun can be had by playing around with x, y, xd, and yd as
     you move about the image.
  */
  for (j = 0; j < dheight; j++) {
    x = sx;
    y = sy;
    for (i = 0; i < video_width; i++) {
      a = ((x >> 12 & 255) * video_width) >> 8;
      b = ((y >> 12 & 255) * video_height) >> 8;
      origin = b * irowstride + a * psize;
      weed_memcpy(&dst[orowstride * j + i * psize], &src[origin], psize);
      x += xd;
      y += yd;
    }
    sx -= yd;
    sy += xd;
  }
}

/////////////////////////////////////////////////////////////////////////////

static weed_error_t rotozoom_init(weed_plant_t *inst) {
  weed_plant_t *in_chan = weed_get_in_channel(inst, 0);
  weed_plant_t *out_chan = weed_get_out_channel(inst, 0);
  weed_plant_t **in_params = weed_get_in_params(inst, NULL);
  int pal = weed_channel_get_palette(in_chan);
  int irow = weed_channel_get_stride(in_chan);
  int width = weed_channel_get_width(out_chan);
  int height = weed_channel_get_height(out_chan);
  int orow = weed_channel_get_stride(out_chan);
  int psize = pixel_size(pal);
  sdata_t *sdata;

  int zoom = weed_param_get_value_int(in_params[P_zoom]);
  int autozoom = weed_param_get_value_boolean(in_params[P_autozoom]);
  weed_free(in_params);

  if (!(weed_instance_get_flags(inst) & WEED_INSTANCE_UPDATE_GUI_ONLY)) {
    sdata = (sdata_t *)weed_calloc(1, sizeof(sdata_t));
    if (!sdata) return WEED_ERROR_MEMORY_ALLOCATION;

    if (1) {
      sdata->path = sdata->zpath = 0;
    }
    weed_set_voidptr_value(inst, "plugin_internal", sdata);
  }
  else sdata = weed_get_voidptr_value(inst, "plugin_internal", NULL);

  return WEED_SUCCESS;
}


static weed_error_t rotozoom_deinit(weed_plant_t *inst) {
  sdata_t *sdata = (sdata_t *)weed_get_voidptr_value(inst, "plugin_internal", NULL);

  if (sdata) weed_free(sdata);
  weed_set_voidptr_value(inst, "plugin_internal", NULL);

  return WEED_SUCCESS;
}


static weed_error_t rotozoom_process(weed_plant_t *inst, weed_timecode_t tc) {
  weed_plant_t *in_chan = weed_get_in_channel(inst, 0);
  weed_plant_t *out_chan = weed_get_out_channel(inst, 0);
  weed_plant_t **in_params = weed_get_in_params(inst, NULL);
  unsigned char *src = weed_channel_get_pixel_data(in_chan);
  unsigned char *dst = weed_channel_get_pixel_data(out_chan);
  int pal = weed_channel_get_palette(in_chan);
  int irow = weed_channel_get_stride(in_chan);
  int iheight = weed_channel_get_height(in_chan);
  int is_threading = weed_is_threading(inst);
  int offset = 0;
  int width = weed_channel_get_width(out_chan);
  int height = weed_channel_get_height(out_chan);
  int orow = weed_channel_get_stride(out_chan);
  int psize = pixel_size(pal);
  sdata_t *sdata = weed_get_voidptr_value(inst, "plugin_internal", NULL);
  if (!sdata) return WEED_ERROR_REINIT_NEEDED;
  else {
    int zoom = weed_param_get_value_int(in_params[P_zoom]);
    int autozoom = weed_param_get_value_boolean(in_params[P_autozoom]);
    weed_free(in_params);

    if (is_threading) {
      offset = weed_channel_get_offset(out_chan);
      src += offset * irow;
      dst += offset * orow;
    }

    if (1) {
      if (is_threading) {
        if (!weed_plant_has_leaf(inst, WEED_LEAF_STATE_UPDATED)) {
          return WEED_ERROR_FILTER_INVALID;
        }
        /* host should set this to WEED_FALSE for the first thread, then wait for WEED_TRUE */
        if (weed_get_boolean_value(inst, WEED_LEAF_STATE_UPDATED, NULL) == WEED_FALSE) {
          if (autozoom == WEED_TRUE) {
            sdata->zpath = (sdata->zpath + 1) & 255;
          } else {
            sdata->zpath = zoom;
          }
          sdata->path = (sdata->path - 1) & 255;
          weed_set_boolean_value(inst, WEED_LEAF_STATE_UPDATED, WEED_TRUE);
        }
      }

      zoom = roto2[sdata->zpath];
      draw_tile(roto[sdata->path], roto[(sdata->path + 128) & 0xFF],
        zoom, src - offset * irow, dst, width, irow, orow, iheight, height, offset, psize);
    }
  }

  return WEED_SUCCESS;
}


WEED_SETUP_START(200, 200) {
  weed_plant_t *host_info = weed_get_host_info(plugin_info);
  weed_plant_t *filter_class;
  uint64_t unique_id;
  int palette_list[] = ALL_PACKED_PALETTES_PLUS;
  weed_plant_t *in_chantmpls[] = {
      weed_channel_template_init("in_channel0", 0),
      NULL};
  weed_plant_t *out_chantmpls[] = {
      weed_channel_template_init("out_channel0", 0),
      NULL};
  weed_plant_t *in_paramtmpls[] = {
      weed_integer_init("zoom", "_Zoom value", 128, 0, 255),
      weed_switch_init("autozoom", "_Auto zoom", WEED_TRUE),
      NULL};
  int filter_flags = WEED_FILTER_HINT_MAY_THREAD | WEED_FILTER_HINT_STATEFUL;

  verbosity = weed_get_host_verbosity(host_info);

  filter_class = weed_filter_class_init("rotozoom", "effecTV", 1, filter_flags, palette_list,
    rotozoom_init, rotozoom_process, rotozoom_deinit, in_chantmpls, out_chantmpls, in_paramtmpls, NULL);

  weed_filter_set_description(filter_class, "Rotate and zoom images");

  weed_plugin_info_add_filter_class(plugin_info, filter_class);

  if (!sscanf(_UNIQUE_ID_, "0X%lX", &unique_id) || !sscanf(_UNIQUE_ID_, "0x%lx", &unique_id)) {
    weed_set_int64_value(plugin_info, WEED_LEAF_UNIQUE_ID, unique_id);
  }

  if (1) {
    // static data for all instances
    for (int i = 0; i < 256; i++) {
      float rad = (float)i * 1.41176 * 0.0174532;
      float c = sin(rad);
      roto[i] = (c + 0.8) * 4096.0;
      roto2[i] = (2.0 * c) * 4096.0;
    }
  }

  weed_plugin_set_package_version(plugin_info, package_version);
}
WEED_SETUP_END;

